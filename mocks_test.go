// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package weos_test

import (
	"context"
	"github.com/wepala/weos"
	"sync"
)

// Ensure, that EventRepositoryMock does implement weos.EventRepository.
// If this is not the case, regenerate this file with moq.
var _ weos.EventRepository = &EventRepositoryMock{}

// EventRepositoryMock is a mock implementation of weos.EventRepository.
//
// 	func TestSomethingThatUsesEventRepository(t *testing.T) {
//
// 		// make and configure a mocked weos.EventRepository
// 		mockedEventRepository := &EventRepositoryMock{
// 			AddSubscriberFunc: func(handler weos.EventHandler)  {
// 				panic("mock out the AddSubscriber method")
// 			},
// 			FlushFunc: func() error {
// 				panic("mock out the Flush method")
// 			},
// 			GetByAggregateFunc: func(ID string) ([]*weos.Event, error) {
// 				panic("mock out the GetByAggregate method")
// 			},
// 			GetByAggregateAndSequenceRangeFunc: func(ID string, start int64, end int64) ([]*weos.Event, error) {
// 				panic("mock out the GetByAggregateAndSequenceRange method")
// 			},
// 			GetByAggregateAndTypeFunc: func(ID string, entityType string) ([]*weos.Event, error) {
// 				panic("mock out the GetByAggregateAndType method")
// 			},
// 			GetSubscribersFunc: func() ([]weos.EventHandler, error) {
// 				panic("mock out the GetSubscribers method")
// 			},
// 			PersistFunc: func(entities []weos.Entity) error {
// 				panic("mock out the Persist method")
// 			},
// 			RemoveFunc: func(entities []weos.Entity) error {
// 				panic("mock out the Remove method")
// 			},
// 		}
//
// 		// use mockedEventRepository in code that requires weos.EventRepository
// 		// and then make assertions.
//
// 	}
type EventRepositoryMock struct {
	// AddSubscriberFunc mocks the AddSubscriber method.
	AddSubscriberFunc func(handler weos.EventHandler)

	// FlushFunc mocks the Flush method.
	FlushFunc func() error

	// GetByAggregateFunc mocks the GetByAggregate method.
	GetByAggregateFunc func(ID string) ([]*weos.Event, error)

	// GetByAggregateAndSequenceRangeFunc mocks the GetByAggregateAndSequenceRange method.
	GetByAggregateAndSequenceRangeFunc func(ID string, start int64, end int64) ([]*weos.Event, error)

	// GetByAggregateAndTypeFunc mocks the GetByAggregateAndType method.
	GetByAggregateAndTypeFunc func(ID string, entityType string) ([]*weos.Event, error)

	// GetSubscribersFunc mocks the GetSubscribers method.
	GetSubscribersFunc func() ([]weos.EventHandler, error)

	// PersistFunc mocks the Persist method.
	PersistFunc func(entities []weos.Entity) error

	// RemoveFunc mocks the Remove method.
	RemoveFunc func(entities []weos.Entity) error

	// calls tracks calls to the methods.
	calls struct {
		// AddSubscriber holds details about calls to the AddSubscriber method.
		AddSubscriber []struct {
			// Handler is the handler argument value.
			Handler weos.EventHandler
		}
		// Flush holds details about calls to the Flush method.
		Flush []struct {
		}
		// GetByAggregate holds details about calls to the GetByAggregate method.
		GetByAggregate []struct {
			// ID is the ID argument value.
			ID string
		}
		// GetByAggregateAndSequenceRange holds details about calls to the GetByAggregateAndSequenceRange method.
		GetByAggregateAndSequenceRange []struct {
			// ID is the ID argument value.
			ID string
			// Start is the start argument value.
			Start int64
			// End is the end argument value.
			End int64
		}
		// GetByAggregateAndType holds details about calls to the GetByAggregateAndType method.
		GetByAggregateAndType []struct {
			// ID is the ID argument value.
			ID string
			// EntityType is the entityType argument value.
			EntityType string
		}
		// GetSubscribers holds details about calls to the GetSubscribers method.
		GetSubscribers []struct {
		}
		// Persist holds details about calls to the Persist method.
		Persist []struct {
			// Entities is the entities argument value.
			Entities []weos.Entity
		}
		// Remove holds details about calls to the Remove method.
		Remove []struct {
			// Entities is the entities argument value.
			Entities []weos.Entity
		}
	}
	lockAddSubscriber                  sync.RWMutex
	lockFlush                          sync.RWMutex
	lockGetByAggregate                 sync.RWMutex
	lockGetByAggregateAndSequenceRange sync.RWMutex
	lockGetByAggregateAndType          sync.RWMutex
	lockGetSubscribers                 sync.RWMutex
	lockPersist                        sync.RWMutex
	lockRemove                         sync.RWMutex
}

// AddSubscriber calls AddSubscriberFunc.
func (mock *EventRepositoryMock) AddSubscriber(handler weos.EventHandler) {
	if mock.AddSubscriberFunc == nil {
		panic("EventRepositoryMock.AddSubscriberFunc: method is nil but EventRepository.AddSubscriber was just called")
	}
	callInfo := struct {
		Handler weos.EventHandler
	}{
		Handler: handler,
	}
	mock.lockAddSubscriber.Lock()
	mock.calls.AddSubscriber = append(mock.calls.AddSubscriber, callInfo)
	mock.lockAddSubscriber.Unlock()
	mock.AddSubscriberFunc(handler)
}

// AddSubscriberCalls gets all the calls that were made to AddSubscriber.
// Check the length with:
//     len(mockedEventRepository.AddSubscriberCalls())
func (mock *EventRepositoryMock) AddSubscriberCalls() []struct {
	Handler weos.EventHandler
} {
	var calls []struct {
		Handler weos.EventHandler
	}
	mock.lockAddSubscriber.RLock()
	calls = mock.calls.AddSubscriber
	mock.lockAddSubscriber.RUnlock()
	return calls
}

// Flush calls FlushFunc.
func (mock *EventRepositoryMock) Flush() error {
	if mock.FlushFunc == nil {
		panic("EventRepositoryMock.FlushFunc: method is nil but EventRepository.Flush was just called")
	}
	callInfo := struct {
	}{}
	mock.lockFlush.Lock()
	mock.calls.Flush = append(mock.calls.Flush, callInfo)
	mock.lockFlush.Unlock()
	return mock.FlushFunc()
}

// FlushCalls gets all the calls that were made to Flush.
// Check the length with:
//     len(mockedEventRepository.FlushCalls())
func (mock *EventRepositoryMock) FlushCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockFlush.RLock()
	calls = mock.calls.Flush
	mock.lockFlush.RUnlock()
	return calls
}

// GetByAggregate calls GetByAggregateFunc.
func (mock *EventRepositoryMock) GetByAggregate(ID string) ([]*weos.Event, error) {
	if mock.GetByAggregateFunc == nil {
		panic("EventRepositoryMock.GetByAggregateFunc: method is nil but EventRepository.GetByAggregate was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: ID,
	}
	mock.lockGetByAggregate.Lock()
	mock.calls.GetByAggregate = append(mock.calls.GetByAggregate, callInfo)
	mock.lockGetByAggregate.Unlock()
	return mock.GetByAggregateFunc(ID)
}

// GetByAggregateCalls gets all the calls that were made to GetByAggregate.
// Check the length with:
//     len(mockedEventRepository.GetByAggregateCalls())
func (mock *EventRepositoryMock) GetByAggregateCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	mock.lockGetByAggregate.RLock()
	calls = mock.calls.GetByAggregate
	mock.lockGetByAggregate.RUnlock()
	return calls
}

// GetByAggregateAndSequenceRange calls GetByAggregateAndSequenceRangeFunc.
func (mock *EventRepositoryMock) GetByAggregateAndSequenceRange(ID string, start int64, end int64) ([]*weos.Event, error) {
	if mock.GetByAggregateAndSequenceRangeFunc == nil {
		panic("EventRepositoryMock.GetByAggregateAndSequenceRangeFunc: method is nil but EventRepository.GetByAggregateAndSequenceRange was just called")
	}
	callInfo := struct {
		ID    string
		Start int64
		End   int64
	}{
		ID:    ID,
		Start: start,
		End:   end,
	}
	mock.lockGetByAggregateAndSequenceRange.Lock()
	mock.calls.GetByAggregateAndSequenceRange = append(mock.calls.GetByAggregateAndSequenceRange, callInfo)
	mock.lockGetByAggregateAndSequenceRange.Unlock()
	return mock.GetByAggregateAndSequenceRangeFunc(ID, start, end)
}

// GetByAggregateAndSequenceRangeCalls gets all the calls that were made to GetByAggregateAndSequenceRange.
// Check the length with:
//     len(mockedEventRepository.GetByAggregateAndSequenceRangeCalls())
func (mock *EventRepositoryMock) GetByAggregateAndSequenceRangeCalls() []struct {
	ID    string
	Start int64
	End   int64
} {
	var calls []struct {
		ID    string
		Start int64
		End   int64
	}
	mock.lockGetByAggregateAndSequenceRange.RLock()
	calls = mock.calls.GetByAggregateAndSequenceRange
	mock.lockGetByAggregateAndSequenceRange.RUnlock()
	return calls
}

// GetByAggregateAndType calls GetByAggregateAndTypeFunc.
func (mock *EventRepositoryMock) GetByAggregateAndType(ID string, entityType string) ([]*weos.Event, error) {
	if mock.GetByAggregateAndTypeFunc == nil {
		panic("EventRepositoryMock.GetByAggregateAndTypeFunc: method is nil but EventRepository.GetByAggregateAndType was just called")
	}
	callInfo := struct {
		ID         string
		EntityType string
	}{
		ID:         ID,
		EntityType: entityType,
	}
	mock.lockGetByAggregateAndType.Lock()
	mock.calls.GetByAggregateAndType = append(mock.calls.GetByAggregateAndType, callInfo)
	mock.lockGetByAggregateAndType.Unlock()
	return mock.GetByAggregateAndTypeFunc(ID, entityType)
}

// GetByAggregateAndTypeCalls gets all the calls that were made to GetByAggregateAndType.
// Check the length with:
//     len(mockedEventRepository.GetByAggregateAndTypeCalls())
func (mock *EventRepositoryMock) GetByAggregateAndTypeCalls() []struct {
	ID         string
	EntityType string
} {
	var calls []struct {
		ID         string
		EntityType string
	}
	mock.lockGetByAggregateAndType.RLock()
	calls = mock.calls.GetByAggregateAndType
	mock.lockGetByAggregateAndType.RUnlock()
	return calls
}

// GetSubscribers calls GetSubscribersFunc.
func (mock *EventRepositoryMock) GetSubscribers() ([]weos.EventHandler, error) {
	if mock.GetSubscribersFunc == nil {
		panic("EventRepositoryMock.GetSubscribersFunc: method is nil but EventRepository.GetSubscribers was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetSubscribers.Lock()
	mock.calls.GetSubscribers = append(mock.calls.GetSubscribers, callInfo)
	mock.lockGetSubscribers.Unlock()
	return mock.GetSubscribersFunc()
}

// GetSubscribersCalls gets all the calls that were made to GetSubscribers.
// Check the length with:
//     len(mockedEventRepository.GetSubscribersCalls())
func (mock *EventRepositoryMock) GetSubscribersCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetSubscribers.RLock()
	calls = mock.calls.GetSubscribers
	mock.lockGetSubscribers.RUnlock()
	return calls
}

// Persist calls PersistFunc.
func (mock *EventRepositoryMock) Persist(entities []weos.Entity) error {
	if mock.PersistFunc == nil {
		panic("EventRepositoryMock.PersistFunc: method is nil but EventRepository.Persist was just called")
	}
	callInfo := struct {
		Entities []weos.Entity
	}{
		Entities: entities,
	}
	mock.lockPersist.Lock()
	mock.calls.Persist = append(mock.calls.Persist, callInfo)
	mock.lockPersist.Unlock()
	return mock.PersistFunc(entities)
}

// PersistCalls gets all the calls that were made to Persist.
// Check the length with:
//     len(mockedEventRepository.PersistCalls())
func (mock *EventRepositoryMock) PersistCalls() []struct {
	Entities []weos.Entity
} {
	var calls []struct {
		Entities []weos.Entity
	}
	mock.lockPersist.RLock()
	calls = mock.calls.Persist
	mock.lockPersist.RUnlock()
	return calls
}

// Remove calls RemoveFunc.
func (mock *EventRepositoryMock) Remove(entities []weos.Entity) error {
	if mock.RemoveFunc == nil {
		panic("EventRepositoryMock.RemoveFunc: method is nil but EventRepository.Remove was just called")
	}
	callInfo := struct {
		Entities []weos.Entity
	}{
		Entities: entities,
	}
	mock.lockRemove.Lock()
	mock.calls.Remove = append(mock.calls.Remove, callInfo)
	mock.lockRemove.Unlock()
	return mock.RemoveFunc(entities)
}

// RemoveCalls gets all the calls that were made to Remove.
// Check the length with:
//     len(mockedEventRepository.RemoveCalls())
func (mock *EventRepositoryMock) RemoveCalls() []struct {
	Entities []weos.Entity
} {
	var calls []struct {
		Entities []weos.Entity
	}
	mock.lockRemove.RLock()
	calls = mock.calls.Remove
	mock.lockRemove.RUnlock()
	return calls
}

// Ensure, that ProjectionMock does implement weos.Projection.
// If this is not the case, regenerate this file with moq.
var _ weos.Projection = &ProjectionMock{}

// ProjectionMock is a mock implementation of weos.Projection.
//
// 	func TestSomethingThatUsesProjection(t *testing.T) {
//
// 		// make and configure a mocked weos.Projection
// 		mockedProjection := &ProjectionMock{
// 			GetEventHandlerFunc: func() weos.EventHandler {
// 				panic("mock out the GetEventHandler method")
// 			},
// 			MigrateFunc: func(ctx context.Context) error {
// 				panic("mock out the Migrate method")
// 			},
// 		}
//
// 		// use mockedProjection in code that requires weos.Projection
// 		// and then make assertions.
//
// 	}
type ProjectionMock struct {
	// GetEventHandlerFunc mocks the GetEventHandler method.
	GetEventHandlerFunc func() weos.EventHandler

	// MigrateFunc mocks the Migrate method.
	MigrateFunc func(ctx context.Context) error

	// calls tracks calls to the methods.
	calls struct {
		// GetEventHandler holds details about calls to the GetEventHandler method.
		GetEventHandler []struct {
		}
		// Migrate holds details about calls to the Migrate method.
		Migrate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockGetEventHandler sync.RWMutex
	lockMigrate         sync.RWMutex
}

// GetEventHandler calls GetEventHandlerFunc.
func (mock *ProjectionMock) GetEventHandler() weos.EventHandler {
	if mock.GetEventHandlerFunc == nil {
		panic("ProjectionMock.GetEventHandlerFunc: method is nil but Projection.GetEventHandler was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetEventHandler.Lock()
	mock.calls.GetEventHandler = append(mock.calls.GetEventHandler, callInfo)
	mock.lockGetEventHandler.Unlock()
	return mock.GetEventHandlerFunc()
}

// GetEventHandlerCalls gets all the calls that were made to GetEventHandler.
// Check the length with:
//     len(mockedProjection.GetEventHandlerCalls())
func (mock *ProjectionMock) GetEventHandlerCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetEventHandler.RLock()
	calls = mock.calls.GetEventHandler
	mock.lockGetEventHandler.RUnlock()
	return calls
}

// Migrate calls MigrateFunc.
func (mock *ProjectionMock) Migrate(ctx context.Context) error {
	if mock.MigrateFunc == nil {
		panic("ProjectionMock.MigrateFunc: method is nil but Projection.Migrate was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockMigrate.Lock()
	mock.calls.Migrate = append(mock.calls.Migrate, callInfo)
	mock.lockMigrate.Unlock()
	return mock.MigrateFunc(ctx)
}

// MigrateCalls gets all the calls that were made to Migrate.
// Check the length with:
//     len(mockedProjection.MigrateCalls())
func (mock *ProjectionMock) MigrateCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockMigrate.RLock()
	calls = mock.calls.Migrate
	mock.lockMigrate.RUnlock()
	return calls
}

// Ensure, that LogMock does implement weos.Log.
// If this is not the case, regenerate this file with moq.
var _ weos.Log = &LogMock{}

// LogMock is a mock implementation of weos.Log.
//
// 	func TestSomethingThatUsesLog(t *testing.T) {
//
// 		// make and configure a mocked weos.Log
// 		mockedLog := &LogMock{
// 			DebugFunc: func(args ...interface{})  {
// 				panic("mock out the Debug method")
// 			},
// 			DebugfFunc: func(format string, args ...interface{})  {
// 				panic("mock out the Debugf method")
// 			},
// 			ErrorFunc: func(args ...interface{})  {
// 				panic("mock out the Error method")
// 			},
// 			ErrorfFunc: func(format string, args ...interface{})  {
// 				panic("mock out the Errorf method")
// 			},
// 			FatalFunc: func(args ...interface{})  {
// 				panic("mock out the Fatal method")
// 			},
// 			FatalfFunc: func(format string, args ...interface{})  {
// 				panic("mock out the Fatalf method")
// 			},
// 			InfoFunc: func(args ...interface{})  {
// 				panic("mock out the Info method")
// 			},
// 			InfofFunc: func(format string, args ...interface{})  {
// 				panic("mock out the Infof method")
// 			},
// 			PanicFunc: func(args ...interface{})  {
// 				panic("mock out the Panic method")
// 			},
// 			PanicfFunc: func(format string, args ...interface{})  {
// 				panic("mock out the Panicf method")
// 			},
// 			PrintFunc: func(args ...interface{})  {
// 				panic("mock out the Print method")
// 			},
// 			PrintfFunc: func(format string, args ...interface{})  {
// 				panic("mock out the Printf method")
// 			},
// 		}
//
// 		// use mockedLog in code that requires weos.Log
// 		// and then make assertions.
//
// 	}
type LogMock struct {
	// DebugFunc mocks the Debug method.
	DebugFunc func(args ...interface{})

	// DebugfFunc mocks the Debugf method.
	DebugfFunc func(format string, args ...interface{})

	// ErrorFunc mocks the Error method.
	ErrorFunc func(args ...interface{})

	// ErrorfFunc mocks the Errorf method.
	ErrorfFunc func(format string, args ...interface{})

	// FatalFunc mocks the Fatal method.
	FatalFunc func(args ...interface{})

	// FatalfFunc mocks the Fatalf method.
	FatalfFunc func(format string, args ...interface{})

	// InfoFunc mocks the Info method.
	InfoFunc func(args ...interface{})

	// InfofFunc mocks the Infof method.
	InfofFunc func(format string, args ...interface{})

	// PanicFunc mocks the Panic method.
	PanicFunc func(args ...interface{})

	// PanicfFunc mocks the Panicf method.
	PanicfFunc func(format string, args ...interface{})

	// PrintFunc mocks the Print method.
	PrintFunc func(args ...interface{})

	// PrintfFunc mocks the Printf method.
	PrintfFunc func(format string, args ...interface{})

	// calls tracks calls to the methods.
	calls struct {
		// Debug holds details about calls to the Debug method.
		Debug []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Debugf holds details about calls to the Debugf method.
		Debugf []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []interface{}
		}
		// Error holds details about calls to the Error method.
		Error []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Errorf holds details about calls to the Errorf method.
		Errorf []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []interface{}
		}
		// Fatal holds details about calls to the Fatal method.
		Fatal []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Fatalf holds details about calls to the Fatalf method.
		Fatalf []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []interface{}
		}
		// Info holds details about calls to the Info method.
		Info []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Infof holds details about calls to the Infof method.
		Infof []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []interface{}
		}
		// Panic holds details about calls to the Panic method.
		Panic []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Panicf holds details about calls to the Panicf method.
		Panicf []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []interface{}
		}
		// Print holds details about calls to the Print method.
		Print []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Printf holds details about calls to the Printf method.
		Printf []struct {
			// Format is the format argument value.
			Format string
			// Args is the args argument value.
			Args []interface{}
		}
	}
	lockDebug  sync.RWMutex
	lockDebugf sync.RWMutex
	lockError  sync.RWMutex
	lockErrorf sync.RWMutex
	lockFatal  sync.RWMutex
	lockFatalf sync.RWMutex
	lockInfo   sync.RWMutex
	lockInfof  sync.RWMutex
	lockPanic  sync.RWMutex
	lockPanicf sync.RWMutex
	lockPrint  sync.RWMutex
	lockPrintf sync.RWMutex
}

// Debug calls DebugFunc.
func (mock *LogMock) Debug(args ...interface{}) {
	if mock.DebugFunc == nil {
		panic("LogMock.DebugFunc: method is nil but Log.Debug was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockDebug.Lock()
	mock.calls.Debug = append(mock.calls.Debug, callInfo)
	mock.lockDebug.Unlock()
	mock.DebugFunc(args...)
}

// DebugCalls gets all the calls that were made to Debug.
// Check the length with:
//     len(mockedLog.DebugCalls())
func (mock *LogMock) DebugCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockDebug.RLock()
	calls = mock.calls.Debug
	mock.lockDebug.RUnlock()
	return calls
}

// Debugf calls DebugfFunc.
func (mock *LogMock) Debugf(format string, args ...interface{}) {
	if mock.DebugfFunc == nil {
		panic("LogMock.DebugfFunc: method is nil but Log.Debugf was just called")
	}
	callInfo := struct {
		Format string
		Args   []interface{}
	}{
		Format: format,
		Args:   args,
	}
	mock.lockDebugf.Lock()
	mock.calls.Debugf = append(mock.calls.Debugf, callInfo)
	mock.lockDebugf.Unlock()
	mock.DebugfFunc(format, args...)
}

// DebugfCalls gets all the calls that were made to Debugf.
// Check the length with:
//     len(mockedLog.DebugfCalls())
func (mock *LogMock) DebugfCalls() []struct {
	Format string
	Args   []interface{}
} {
	var calls []struct {
		Format string
		Args   []interface{}
	}
	mock.lockDebugf.RLock()
	calls = mock.calls.Debugf
	mock.lockDebugf.RUnlock()
	return calls
}

// Error calls ErrorFunc.
func (mock *LogMock) Error(args ...interface{}) {
	if mock.ErrorFunc == nil {
		panic("LogMock.ErrorFunc: method is nil but Log.Error was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockError.Lock()
	mock.calls.Error = append(mock.calls.Error, callInfo)
	mock.lockError.Unlock()
	mock.ErrorFunc(args...)
}

// ErrorCalls gets all the calls that were made to Error.
// Check the length with:
//     len(mockedLog.ErrorCalls())
func (mock *LogMock) ErrorCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockError.RLock()
	calls = mock.calls.Error
	mock.lockError.RUnlock()
	return calls
}

// Errorf calls ErrorfFunc.
func (mock *LogMock) Errorf(format string, args ...interface{}) {
	if mock.ErrorfFunc == nil {
		panic("LogMock.ErrorfFunc: method is nil but Log.Errorf was just called")
	}
	callInfo := struct {
		Format string
		Args   []interface{}
	}{
		Format: format,
		Args:   args,
	}
	mock.lockErrorf.Lock()
	mock.calls.Errorf = append(mock.calls.Errorf, callInfo)
	mock.lockErrorf.Unlock()
	mock.ErrorfFunc(format, args...)
}

// ErrorfCalls gets all the calls that were made to Errorf.
// Check the length with:
//     len(mockedLog.ErrorfCalls())
func (mock *LogMock) ErrorfCalls() []struct {
	Format string
	Args   []interface{}
} {
	var calls []struct {
		Format string
		Args   []interface{}
	}
	mock.lockErrorf.RLock()
	calls = mock.calls.Errorf
	mock.lockErrorf.RUnlock()
	return calls
}

// Fatal calls FatalFunc.
func (mock *LogMock) Fatal(args ...interface{}) {
	if mock.FatalFunc == nil {
		panic("LogMock.FatalFunc: method is nil but Log.Fatal was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockFatal.Lock()
	mock.calls.Fatal = append(mock.calls.Fatal, callInfo)
	mock.lockFatal.Unlock()
	mock.FatalFunc(args...)
}

// FatalCalls gets all the calls that were made to Fatal.
// Check the length with:
//     len(mockedLog.FatalCalls())
func (mock *LogMock) FatalCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockFatal.RLock()
	calls = mock.calls.Fatal
	mock.lockFatal.RUnlock()
	return calls
}

// Fatalf calls FatalfFunc.
func (mock *LogMock) Fatalf(format string, args ...interface{}) {
	if mock.FatalfFunc == nil {
		panic("LogMock.FatalfFunc: method is nil but Log.Fatalf was just called")
	}
	callInfo := struct {
		Format string
		Args   []interface{}
	}{
		Format: format,
		Args:   args,
	}
	mock.lockFatalf.Lock()
	mock.calls.Fatalf = append(mock.calls.Fatalf, callInfo)
	mock.lockFatalf.Unlock()
	mock.FatalfFunc(format, args...)
}

// FatalfCalls gets all the calls that were made to Fatalf.
// Check the length with:
//     len(mockedLog.FatalfCalls())
func (mock *LogMock) FatalfCalls() []struct {
	Format string
	Args   []interface{}
} {
	var calls []struct {
		Format string
		Args   []interface{}
	}
	mock.lockFatalf.RLock()
	calls = mock.calls.Fatalf
	mock.lockFatalf.RUnlock()
	return calls
}

// Info calls InfoFunc.
func (mock *LogMock) Info(args ...interface{}) {
	if mock.InfoFunc == nil {
		panic("LogMock.InfoFunc: method is nil but Log.Info was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockInfo.Lock()
	mock.calls.Info = append(mock.calls.Info, callInfo)
	mock.lockInfo.Unlock()
	mock.InfoFunc(args...)
}

// InfoCalls gets all the calls that were made to Info.
// Check the length with:
//     len(mockedLog.InfoCalls())
func (mock *LogMock) InfoCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockInfo.RLock()
	calls = mock.calls.Info
	mock.lockInfo.RUnlock()
	return calls
}

// Infof calls InfofFunc.
func (mock *LogMock) Infof(format string, args ...interface{}) {
	if mock.InfofFunc == nil {
		panic("LogMock.InfofFunc: method is nil but Log.Infof was just called")
	}
	callInfo := struct {
		Format string
		Args   []interface{}
	}{
		Format: format,
		Args:   args,
	}
	mock.lockInfof.Lock()
	mock.calls.Infof = append(mock.calls.Infof, callInfo)
	mock.lockInfof.Unlock()
	mock.InfofFunc(format, args...)
}

// InfofCalls gets all the calls that were made to Infof.
// Check the length with:
//     len(mockedLog.InfofCalls())
func (mock *LogMock) InfofCalls() []struct {
	Format string
	Args   []interface{}
} {
	var calls []struct {
		Format string
		Args   []interface{}
	}
	mock.lockInfof.RLock()
	calls = mock.calls.Infof
	mock.lockInfof.RUnlock()
	return calls
}

// Panic calls PanicFunc.
func (mock *LogMock) Panic(args ...interface{}) {
	if mock.PanicFunc == nil {
		panic("LogMock.PanicFunc: method is nil but Log.Panic was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockPanic.Lock()
	mock.calls.Panic = append(mock.calls.Panic, callInfo)
	mock.lockPanic.Unlock()
	mock.PanicFunc(args...)
}

// PanicCalls gets all the calls that were made to Panic.
// Check the length with:
//     len(mockedLog.PanicCalls())
func (mock *LogMock) PanicCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockPanic.RLock()
	calls = mock.calls.Panic
	mock.lockPanic.RUnlock()
	return calls
}

// Panicf calls PanicfFunc.
func (mock *LogMock) Panicf(format string, args ...interface{}) {
	if mock.PanicfFunc == nil {
		panic("LogMock.PanicfFunc: method is nil but Log.Panicf was just called")
	}
	callInfo := struct {
		Format string
		Args   []interface{}
	}{
		Format: format,
		Args:   args,
	}
	mock.lockPanicf.Lock()
	mock.calls.Panicf = append(mock.calls.Panicf, callInfo)
	mock.lockPanicf.Unlock()
	mock.PanicfFunc(format, args...)
}

// PanicfCalls gets all the calls that were made to Panicf.
// Check the length with:
//     len(mockedLog.PanicfCalls())
func (mock *LogMock) PanicfCalls() []struct {
	Format string
	Args   []interface{}
} {
	var calls []struct {
		Format string
		Args   []interface{}
	}
	mock.lockPanicf.RLock()
	calls = mock.calls.Panicf
	mock.lockPanicf.RUnlock()
	return calls
}

// Print calls PrintFunc.
func (mock *LogMock) Print(args ...interface{}) {
	if mock.PrintFunc == nil {
		panic("LogMock.PrintFunc: method is nil but Log.Print was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	mock.lockPrint.Lock()
	mock.calls.Print = append(mock.calls.Print, callInfo)
	mock.lockPrint.Unlock()
	mock.PrintFunc(args...)
}

// PrintCalls gets all the calls that were made to Print.
// Check the length with:
//     len(mockedLog.PrintCalls())
func (mock *LogMock) PrintCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	mock.lockPrint.RLock()
	calls = mock.calls.Print
	mock.lockPrint.RUnlock()
	return calls
}

// Printf calls PrintfFunc.
func (mock *LogMock) Printf(format string, args ...interface{}) {
	if mock.PrintfFunc == nil {
		panic("LogMock.PrintfFunc: method is nil but Log.Printf was just called")
	}
	callInfo := struct {
		Format string
		Args   []interface{}
	}{
		Format: format,
		Args:   args,
	}
	mock.lockPrintf.Lock()
	mock.calls.Printf = append(mock.calls.Printf, callInfo)
	mock.lockPrintf.Unlock()
	mock.PrintfFunc(format, args...)
}

// PrintfCalls gets all the calls that were made to Printf.
// Check the length with:
//     len(mockedLog.PrintfCalls())
func (mock *LogMock) PrintfCalls() []struct {
	Format string
	Args   []interface{}
} {
	var calls []struct {
		Format string
		Args   []interface{}
	}
	mock.lockPrintf.RLock()
	calls = mock.calls.Printf
	mock.lockPrintf.RUnlock()
	return calls
}

// Ensure, that DispatcherMock does implement weos.Dispatcher.
// If this is not the case, regenerate this file with moq.
var _ weos.Dispatcher = &DispatcherMock{}

// DispatcherMock is a mock implementation of weos.Dispatcher.
//
// 	func TestSomethingThatUsesDispatcher(t *testing.T) {
//
// 		// make and configure a mocked weos.Dispatcher
// 		mockedDispatcher := &DispatcherMock{
// 			AddSubscriberFunc: func(command *weos.Command, handler weos.CommandHandler) map[string][]weos.CommandHandler {
// 				panic("mock out the AddSubscriber method")
// 			},
// 			DispatchFunc: func(ctx context.Context, command *weos.Command) error {
// 				panic("mock out the Dispatch method")
// 			},
// 			GetSubscribersFunc: func() map[string][]weos.CommandHandler {
// 				panic("mock out the GetSubscribers method")
// 			},
// 		}
//
// 		// use mockedDispatcher in code that requires weos.Dispatcher
// 		// and then make assertions.
//
// 	}
type DispatcherMock struct {
	// AddSubscriberFunc mocks the AddSubscriber method.
	AddSubscriberFunc func(command *weos.Command, handler weos.CommandHandler) map[string][]weos.CommandHandler

	// DispatchFunc mocks the Dispatch method.
	DispatchFunc func(ctx context.Context, command *weos.Command) error

	// GetSubscribersFunc mocks the GetSubscribers method.
	GetSubscribersFunc func() map[string][]weos.CommandHandler

	// calls tracks calls to the methods.
	calls struct {
		// AddSubscriber holds details about calls to the AddSubscriber method.
		AddSubscriber []struct {
			// Command is the command argument value.
			Command *weos.Command
			// Handler is the handler argument value.
			Handler weos.CommandHandler
		}
		// Dispatch holds details about calls to the Dispatch method.
		Dispatch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Command is the command argument value.
			Command *weos.Command
		}
		// GetSubscribers holds details about calls to the GetSubscribers method.
		GetSubscribers []struct {
		}
	}
	lockAddSubscriber  sync.RWMutex
	lockDispatch       sync.RWMutex
	lockGetSubscribers sync.RWMutex
}

// AddSubscriber calls AddSubscriberFunc.
func (mock *DispatcherMock) AddSubscriber(command *weos.Command, handler weos.CommandHandler) map[string][]weos.CommandHandler {
	if mock.AddSubscriberFunc == nil {
		panic("DispatcherMock.AddSubscriberFunc: method is nil but Dispatcher.AddSubscriber was just called")
	}
	callInfo := struct {
		Command *weos.Command
		Handler weos.CommandHandler
	}{
		Command: command,
		Handler: handler,
	}
	mock.lockAddSubscriber.Lock()
	mock.calls.AddSubscriber = append(mock.calls.AddSubscriber, callInfo)
	mock.lockAddSubscriber.Unlock()
	return mock.AddSubscriberFunc(command, handler)
}

// AddSubscriberCalls gets all the calls that were made to AddSubscriber.
// Check the length with:
//     len(mockedDispatcher.AddSubscriberCalls())
func (mock *DispatcherMock) AddSubscriberCalls() []struct {
	Command *weos.Command
	Handler weos.CommandHandler
} {
	var calls []struct {
		Command *weos.Command
		Handler weos.CommandHandler
	}
	mock.lockAddSubscriber.RLock()
	calls = mock.calls.AddSubscriber
	mock.lockAddSubscriber.RUnlock()
	return calls
}

// Dispatch calls DispatchFunc.
func (mock *DispatcherMock) Dispatch(ctx context.Context, command *weos.Command) error {
	if mock.DispatchFunc == nil {
		panic("DispatcherMock.DispatchFunc: method is nil but Dispatcher.Dispatch was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Command *weos.Command
	}{
		Ctx:     ctx,
		Command: command,
	}
	mock.lockDispatch.Lock()
	mock.calls.Dispatch = append(mock.calls.Dispatch, callInfo)
	mock.lockDispatch.Unlock()
	return mock.DispatchFunc(ctx, command)
}

// DispatchCalls gets all the calls that were made to Dispatch.
// Check the length with:
//     len(mockedDispatcher.DispatchCalls())
func (mock *DispatcherMock) DispatchCalls() []struct {
	Ctx     context.Context
	Command *weos.Command
} {
	var calls []struct {
		Ctx     context.Context
		Command *weos.Command
	}
	mock.lockDispatch.RLock()
	calls = mock.calls.Dispatch
	mock.lockDispatch.RUnlock()
	return calls
}

// GetSubscribers calls GetSubscribersFunc.
func (mock *DispatcherMock) GetSubscribers() map[string][]weos.CommandHandler {
	if mock.GetSubscribersFunc == nil {
		panic("DispatcherMock.GetSubscribersFunc: method is nil but Dispatcher.GetSubscribers was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetSubscribers.Lock()
	mock.calls.GetSubscribers = append(mock.calls.GetSubscribers, callInfo)
	mock.lockGetSubscribers.Unlock()
	return mock.GetSubscribersFunc()
}

// GetSubscribersCalls gets all the calls that were made to GetSubscribers.
// Check the length with:
//     len(mockedDispatcher.GetSubscribersCalls())
func (mock *DispatcherMock) GetSubscribersCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetSubscribers.RLock()
	calls = mock.calls.GetSubscribers
	mock.lockGetSubscribers.RUnlock()
	return calls
}
