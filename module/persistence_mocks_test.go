// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package module_test

import (
	"context"
	"github.com/wepala/weos/domain"
	"github.com/wepala/weos/persistence"
	"sync"
)

// Ensure, that EventRepositoryMock does implement persistence.EventRepository.
// If this is not the case, regenerate this file with moq.
var _ persistence.EventRepository = &EventRepositoryMock{}

// EventRepositoryMock is a mock implementation of persistence.EventRepository.
//
// 	func TestSomethingThatUsesEventRepository(t *testing.T) {
//
// 		// make and configure a mocked persistence.EventRepository
// 		mockedEventRepository := &EventRepositoryMock{
// 			AddSubscriberFunc: func(handler persistence.EventHandler)  {
// 				panic("mock out the AddSubscriber method")
// 			},
// 			FlushFunc: func() error {
// 				panic("mock out the Flush method")
// 			},
// 			GetByAggregateFunc: func(ID string) ([]*domain.Event, error) {
// 				panic("mock out the GetByAggregate method")
// 			},
// 			GetByAggregateAndSequenceRangeFunc: func(ID string, start int64, end int64) ([]*domain.Event, error) {
// 				panic("mock out the GetByAggregateAndSequenceRange method")
// 			},
// 			GetByAggregateAndTypeFunc: func(ID string, entityType string) ([]*domain.Event, error) {
// 				panic("mock out the GetByAggregateAndType method")
// 			},
// 			GetSubscribersFunc: func() ([]persistence.EventHandler, error) {
// 				panic("mock out the GetSubscribers method")
// 			},
// 			PersistFunc: func(entities []domain.Entity) error {
// 				panic("mock out the Persist method")
// 			},
// 			RemoveFunc: func(entities []domain.Entity) error {
// 				panic("mock out the Remove method")
// 			},
// 		}
//
// 		// use mockedEventRepository in code that requires persistence.EventRepository
// 		// and then make assertions.
//
// 	}
type EventRepositoryMock struct {
	// AddSubscriberFunc mocks the AddSubscriber method.
	AddSubscriberFunc func(handler persistence.EventHandler)

	// FlushFunc mocks the Flush method.
	FlushFunc func() error

	// GetByAggregateFunc mocks the GetByAggregate method.
	GetByAggregateFunc func(ID string) ([]*domain.Event, error)

	// GetByAggregateAndSequenceRangeFunc mocks the GetByAggregateAndSequenceRange method.
	GetByAggregateAndSequenceRangeFunc func(ID string, start int64, end int64) ([]*domain.Event, error)

	// GetByAggregateAndTypeFunc mocks the GetByAggregateAndType method.
	GetByAggregateAndTypeFunc func(ID string, entityType string) ([]*domain.Event, error)

	// GetSubscribersFunc mocks the GetSubscribers method.
	GetSubscribersFunc func() ([]persistence.EventHandler, error)

	// PersistFunc mocks the Persist method.
	PersistFunc func(entities []domain.Entity) error

	// RemoveFunc mocks the Remove method.
	RemoveFunc func(entities []domain.Entity) error

	// calls tracks calls to the methods.
	calls struct {
		// AddSubscriber holds details about calls to the AddSubscriber method.
		AddSubscriber []struct {
			// Handler is the handler argument value.
			Handler persistence.EventHandler
		}
		// Flush holds details about calls to the Flush method.
		Flush []struct {
		}
		// GetByAggregate holds details about calls to the GetByAggregate method.
		GetByAggregate []struct {
			// ID is the ID argument value.
			ID string
		}
		// GetByAggregateAndSequenceRange holds details about calls to the GetByAggregateAndSequenceRange method.
		GetByAggregateAndSequenceRange []struct {
			// ID is the ID argument value.
			ID string
			// Start is the start argument value.
			Start int64
			// End is the end argument value.
			End int64
		}
		// GetByAggregateAndType holds details about calls to the GetByAggregateAndType method.
		GetByAggregateAndType []struct {
			// ID is the ID argument value.
			ID string
			// EntityType is the entityType argument value.
			EntityType string
		}
		// GetSubscribers holds details about calls to the GetSubscribers method.
		GetSubscribers []struct {
		}
		// Persist holds details about calls to the Persist method.
		Persist []struct {
			// Entities is the entities argument value.
			Entities []domain.Entity
		}
		// Remove holds details about calls to the Remove method.
		Remove []struct {
			// Entities is the entities argument value.
			Entities []domain.Entity
		}
	}
	lockAddSubscriber                  sync.RWMutex
	lockFlush                          sync.RWMutex
	lockGetByAggregate                 sync.RWMutex
	lockGetByAggregateAndSequenceRange sync.RWMutex
	lockGetByAggregateAndType          sync.RWMutex
	lockGetSubscribers                 sync.RWMutex
	lockPersist                        sync.RWMutex
	lockRemove                         sync.RWMutex
}

// AddSubscriber calls AddSubscriberFunc.
func (mock *EventRepositoryMock) AddSubscriber(handler persistence.EventHandler) {
	if mock.AddSubscriberFunc == nil {
		panic("EventRepositoryMock.AddSubscriberFunc: method is nil but EventRepository.AddSubscriber was just called")
	}
	callInfo := struct {
		Handler persistence.EventHandler
	}{
		Handler: handler,
	}
	mock.lockAddSubscriber.Lock()
	mock.calls.AddSubscriber = append(mock.calls.AddSubscriber, callInfo)
	mock.lockAddSubscriber.Unlock()
	mock.AddSubscriberFunc(handler)
}

// AddSubscriberCalls gets all the calls that were made to AddSubscriber.
// Check the length with:
//     len(mockedEventRepository.AddSubscriberCalls())
func (mock *EventRepositoryMock) AddSubscriberCalls() []struct {
	Handler persistence.EventHandler
} {
	var calls []struct {
		Handler persistence.EventHandler
	}
	mock.lockAddSubscriber.RLock()
	calls = mock.calls.AddSubscriber
	mock.lockAddSubscriber.RUnlock()
	return calls
}

// Flush calls FlushFunc.
func (mock *EventRepositoryMock) Flush() error {
	if mock.FlushFunc == nil {
		panic("EventRepositoryMock.FlushFunc: method is nil but EventRepository.Flush was just called")
	}
	callInfo := struct {
	}{}
	mock.lockFlush.Lock()
	mock.calls.Flush = append(mock.calls.Flush, callInfo)
	mock.lockFlush.Unlock()
	return mock.FlushFunc()
}

// FlushCalls gets all the calls that were made to Flush.
// Check the length with:
//     len(mockedEventRepository.FlushCalls())
func (mock *EventRepositoryMock) FlushCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockFlush.RLock()
	calls = mock.calls.Flush
	mock.lockFlush.RUnlock()
	return calls
}

// GetByAggregate calls GetByAggregateFunc.
func (mock *EventRepositoryMock) GetByAggregate(ID string) ([]*domain.Event, error) {
	if mock.GetByAggregateFunc == nil {
		panic("EventRepositoryMock.GetByAggregateFunc: method is nil but EventRepository.GetByAggregate was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: ID,
	}
	mock.lockGetByAggregate.Lock()
	mock.calls.GetByAggregate = append(mock.calls.GetByAggregate, callInfo)
	mock.lockGetByAggregate.Unlock()
	return mock.GetByAggregateFunc(ID)
}

// GetByAggregateCalls gets all the calls that were made to GetByAggregate.
// Check the length with:
//     len(mockedEventRepository.GetByAggregateCalls())
func (mock *EventRepositoryMock) GetByAggregateCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	mock.lockGetByAggregate.RLock()
	calls = mock.calls.GetByAggregate
	mock.lockGetByAggregate.RUnlock()
	return calls
}

// GetByAggregateAndSequenceRange calls GetByAggregateAndSequenceRangeFunc.
func (mock *EventRepositoryMock) GetByAggregateAndSequenceRange(ID string, start int64, end int64) ([]*domain.Event, error) {
	if mock.GetByAggregateAndSequenceRangeFunc == nil {
		panic("EventRepositoryMock.GetByAggregateAndSequenceRangeFunc: method is nil but EventRepository.GetByAggregateAndSequenceRange was just called")
	}
	callInfo := struct {
		ID    string
		Start int64
		End   int64
	}{
		ID:    ID,
		Start: start,
		End:   end,
	}
	mock.lockGetByAggregateAndSequenceRange.Lock()
	mock.calls.GetByAggregateAndSequenceRange = append(mock.calls.GetByAggregateAndSequenceRange, callInfo)
	mock.lockGetByAggregateAndSequenceRange.Unlock()
	return mock.GetByAggregateAndSequenceRangeFunc(ID, start, end)
}

// GetByAggregateAndSequenceRangeCalls gets all the calls that were made to GetByAggregateAndSequenceRange.
// Check the length with:
//     len(mockedEventRepository.GetByAggregateAndSequenceRangeCalls())
func (mock *EventRepositoryMock) GetByAggregateAndSequenceRangeCalls() []struct {
	ID    string
	Start int64
	End   int64
} {
	var calls []struct {
		ID    string
		Start int64
		End   int64
	}
	mock.lockGetByAggregateAndSequenceRange.RLock()
	calls = mock.calls.GetByAggregateAndSequenceRange
	mock.lockGetByAggregateAndSequenceRange.RUnlock()
	return calls
}

// GetByAggregateAndType calls GetByAggregateAndTypeFunc.
func (mock *EventRepositoryMock) GetByAggregateAndType(ID string, entityType string) ([]*domain.Event, error) {
	if mock.GetByAggregateAndTypeFunc == nil {
		panic("EventRepositoryMock.GetByAggregateAndTypeFunc: method is nil but EventRepository.GetByAggregateAndType was just called")
	}
	callInfo := struct {
		ID         string
		EntityType string
	}{
		ID:         ID,
		EntityType: entityType,
	}
	mock.lockGetByAggregateAndType.Lock()
	mock.calls.GetByAggregateAndType = append(mock.calls.GetByAggregateAndType, callInfo)
	mock.lockGetByAggregateAndType.Unlock()
	return mock.GetByAggregateAndTypeFunc(ID, entityType)
}

// GetByAggregateAndTypeCalls gets all the calls that were made to GetByAggregateAndType.
// Check the length with:
//     len(mockedEventRepository.GetByAggregateAndTypeCalls())
func (mock *EventRepositoryMock) GetByAggregateAndTypeCalls() []struct {
	ID         string
	EntityType string
} {
	var calls []struct {
		ID         string
		EntityType string
	}
	mock.lockGetByAggregateAndType.RLock()
	calls = mock.calls.GetByAggregateAndType
	mock.lockGetByAggregateAndType.RUnlock()
	return calls
}

// GetSubscribers calls GetSubscribersFunc.
func (mock *EventRepositoryMock) GetSubscribers() ([]persistence.EventHandler, error) {
	if mock.GetSubscribersFunc == nil {
		panic("EventRepositoryMock.GetSubscribersFunc: method is nil but EventRepository.GetSubscribers was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetSubscribers.Lock()
	mock.calls.GetSubscribers = append(mock.calls.GetSubscribers, callInfo)
	mock.lockGetSubscribers.Unlock()
	return mock.GetSubscribersFunc()
}

// GetSubscribersCalls gets all the calls that were made to GetSubscribers.
// Check the length with:
//     len(mockedEventRepository.GetSubscribersCalls())
func (mock *EventRepositoryMock) GetSubscribersCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetSubscribers.RLock()
	calls = mock.calls.GetSubscribers
	mock.lockGetSubscribers.RUnlock()
	return calls
}

// Persist calls PersistFunc.
func (mock *EventRepositoryMock) Persist(entities []domain.Entity) error {
	if mock.PersistFunc == nil {
		panic("EventRepositoryMock.PersistFunc: method is nil but EventRepository.Persist was just called")
	}
	callInfo := struct {
		Entities []domain.Entity
	}{
		Entities: entities,
	}
	mock.lockPersist.Lock()
	mock.calls.Persist = append(mock.calls.Persist, callInfo)
	mock.lockPersist.Unlock()
	return mock.PersistFunc(entities)
}

// PersistCalls gets all the calls that were made to Persist.
// Check the length with:
//     len(mockedEventRepository.PersistCalls())
func (mock *EventRepositoryMock) PersistCalls() []struct {
	Entities []domain.Entity
} {
	var calls []struct {
		Entities []domain.Entity
	}
	mock.lockPersist.RLock()
	calls = mock.calls.Persist
	mock.lockPersist.RUnlock()
	return calls
}

// Remove calls RemoveFunc.
func (mock *EventRepositoryMock) Remove(entities []domain.Entity) error {
	if mock.RemoveFunc == nil {
		panic("EventRepositoryMock.RemoveFunc: method is nil but EventRepository.Remove was just called")
	}
	callInfo := struct {
		Entities []domain.Entity
	}{
		Entities: entities,
	}
	mock.lockRemove.Lock()
	mock.calls.Remove = append(mock.calls.Remove, callInfo)
	mock.lockRemove.Unlock()
	return mock.RemoveFunc(entities)
}

// RemoveCalls gets all the calls that were made to Remove.
// Check the length with:
//     len(mockedEventRepository.RemoveCalls())
func (mock *EventRepositoryMock) RemoveCalls() []struct {
	Entities []domain.Entity
} {
	var calls []struct {
		Entities []domain.Entity
	}
	mock.lockRemove.RLock()
	calls = mock.calls.Remove
	mock.lockRemove.RUnlock()
	return calls
}

// Ensure, that ProjectionMock does implement persistence.Projection.
// If this is not the case, regenerate this file with moq.
var _ persistence.Projection = &ProjectionMock{}

// ProjectionMock is a mock implementation of persistence.Projection.
//
// 	func TestSomethingThatUsesProjection(t *testing.T) {
//
// 		// make and configure a mocked persistence.Projection
// 		mockedProjection := &ProjectionMock{
// 			GetEventHandlerFunc: func() persistence.EventHandler {
// 				panic("mock out the GetEventHandler method")
// 			},
// 			MigrateFunc: func(ctx context.Context) error {
// 				panic("mock out the Migrate method")
// 			},
// 		}
//
// 		// use mockedProjection in code that requires persistence.Projection
// 		// and then make assertions.
//
// 	}
type ProjectionMock struct {
	// GetEventHandlerFunc mocks the GetEventHandler method.
	GetEventHandlerFunc func() persistence.EventHandler

	// MigrateFunc mocks the Migrate method.
	MigrateFunc func(ctx context.Context) error

	// calls tracks calls to the methods.
	calls struct {
		// GetEventHandler holds details about calls to the GetEventHandler method.
		GetEventHandler []struct {
		}
		// Migrate holds details about calls to the Migrate method.
		Migrate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockGetEventHandler sync.RWMutex
	lockMigrate         sync.RWMutex
}

// GetEventHandler calls GetEventHandlerFunc.
func (mock *ProjectionMock) GetEventHandler() persistence.EventHandler {
	if mock.GetEventHandlerFunc == nil {
		panic("ProjectionMock.GetEventHandlerFunc: method is nil but Projection.GetEventHandler was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetEventHandler.Lock()
	mock.calls.GetEventHandler = append(mock.calls.GetEventHandler, callInfo)
	mock.lockGetEventHandler.Unlock()
	return mock.GetEventHandlerFunc()
}

// GetEventHandlerCalls gets all the calls that were made to GetEventHandler.
// Check the length with:
//     len(mockedProjection.GetEventHandlerCalls())
func (mock *ProjectionMock) GetEventHandlerCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetEventHandler.RLock()
	calls = mock.calls.GetEventHandler
	mock.lockGetEventHandler.RUnlock()
	return calls
}

// Migrate calls MigrateFunc.
func (mock *ProjectionMock) Migrate(ctx context.Context) error {
	if mock.MigrateFunc == nil {
		panic("ProjectionMock.MigrateFunc: method is nil but Projection.Migrate was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockMigrate.Lock()
	mock.calls.Migrate = append(mock.calls.Migrate, callInfo)
	mock.lockMigrate.Unlock()
	return mock.MigrateFunc(ctx)
}

// MigrateCalls gets all the calls that were made to Migrate.
// Check the length with:
//     len(mockedProjection.MigrateCalls())
func (mock *ProjectionMock) MigrateCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockMigrate.RLock()
	calls = mock.calls.Migrate
	mock.lockMigrate.RUnlock()
	return calls
}
